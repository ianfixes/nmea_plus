#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.8
# from lexical definition file "/home/ismael/rlink/nmea_plus/parser/tokenizer.rex".
#++


module NMEAPlus
class Decoder < Parser  # The source file is in .rex format -- indentation and most yard documentation is impossible.  This class does a very basic parse of an input line, calling {NMEAPlus::MessageFactory.create} on the result.  In parser.y, this is currently defined to be a {NMEAPlus::NMEAMessageFactory} if the line begins with `$` and {NMEAPlus::AISMessageFactory} if the line begins with `!`.  In pratice, you should be using {NMEAPlus::SourceDecoder} (which wraps this class) to parse messages from an IO object; this class can only parse individual strings.
      require 'strscan'

      class ScanError < StandardError ; end

      attr_reader   :lineno
      attr_reader   :filename
      attr_accessor :state

      def scan_setup(str)
        @ss = StringScanner.new(str)
        @lineno =  1
        @state  = nil
      end

      def action
        yield
      end

      def scan_str(str)
        scan_setup(str)
        do_parse
      end
      alias :scan :scan_str

      def load_file( filename )
        @filename = filename
        File.open(filename, "r") do |f|
          scan_setup(f.read)
        end
      end

      def scan_file( filename )
        load_file(filename)
        do_parse
      end


        def next_token
          return if @ss.eos?

          # skips empty actions
          until token = _next_token or @ss.eos?; end
          token
        end

        def _next_token
          text = @ss.peek(1)
          @lineno  +=  1  if text == "\n"
          token = case @state
            when nil
          case
                  when (text = @ss.scan(/\*[0-9A-F]{2}[\w\n\r]*/i))
                     action { [:CSUM, text[1..2]] }

                  when (text = @ss.scan(/\$/i))
                     action { [:CASH, text] }

                  when (text = @ss.scan(/!/i))
                     action { [:BANG, text] }

                  when (text = @ss.scan(/[^\*]+/i))
                     action { [:DATA, text] }

          
          else
            text = @ss.string[@ss.pos .. -1]
            raise  ScanError, "can not match: '" + text + "'"
          end  # if

        else
          raise  ScanError, "undefined state: '" + state.to_s + "'"
        end  # case state
          token
        end  # def _next_token

  def parse(input)
    @yydebug = true if ENV['DEBUG_RACC']
    scan_str(input)
  end
  def tokenize(input)
    scan_setup(input)
    ret = []
    last_token = nil
    loop do
      last_token = next_token
      break if last_token.nil?
      ret << last_token
    end
    ret
  end
  end # class
end # class
